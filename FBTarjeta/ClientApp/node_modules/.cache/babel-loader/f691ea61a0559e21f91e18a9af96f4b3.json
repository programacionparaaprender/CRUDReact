{"ast":null,"code":"// -----------------\n// STATE - This defines the type of data maintained in the Redux store.\n// -----------------\n// ACTIONS - These are serializable (hence replayable) descriptions of state transitions.\n// They do not themselves have any side-effects; they just describe something that is going to happen.\n// Use @typeName and isActionType for type detection that works even after serialization/deserialization.\n// Declare a 'discriminated union' type. This guarantees that all references to 'type' properties contain one of the\n// declared type strings (and not any other arbitrary string).\n// ----------------\n// ACTION CREATORS - These are functions exposed to UI components that will trigger a state transition.\n// They don't directly mutate state, but they can have external side-effects (such as loading data).\nexport var actionCreators = {\n  increment: function increment() {\n    return {\n      payload: 'data',\n      type: 'INCREMENT_COUNT'\n    };\n  },\n  decrement: function decrement() {\n    return {\n      type: 'DECREMENT_COUNT'\n    };\n  }\n  /* addToCart: (productId:any) => (dispatch, getState) => {\n      if (getState().products.byId[productId].inventory > 0) {\n        dispatch(addToCartUnsafe(productId))\n      }\n  } */\n\n}; // ----------------\n// REDUCER - For a given state and action, returns the new state. To support time travel, this must not mutate the old state.\n\nexport var reducer = function reducer(state, incomingAction) {\n  if (state === undefined) {\n    return {\n      count: 0\n    };\n  }\n\n  console.log('incomingAction: ' + JSON.stringify(incomingAction));\n  var action = incomingAction;\n\n  switch (action.type) {\n    case 'INCREMENT_COUNT':\n      return {\n        count: state.count + 1\n      };\n\n    case 'DECREMENT_COUNT':\n      return {\n        count: state.count - 1\n      };\n\n    default:\n      return state;\n  }\n};","map":{"version":3,"sources":["C:/Users/Bus209/Documents/htdocs/CRUDReact/FBTarjeta/ClientApp/src/store/Counter.ts"],"names":["actionCreators","increment","payload","type","decrement","reducer","state","incomingAction","undefined","count","console","log","JSON","stringify","action"],"mappings":"AAEA;AACA;AAMA;AACA;AACA;AACA;AAOA;AACA;AAGA;AACA;AACA;AAEA,OAAO,IAAMA,cAAc,GAAG;AAC1BC,EAAAA,SAAS,EAAE;AAAA,WAAO;AAAEC,MAAAA,OAAO,EAAC,MAAV;AAAiBC,MAAAA,IAAI,EAAE;AAAvB,KAAP;AAAA,GADe;AAE1BC,EAAAA,SAAS,EAAE;AAAA,WAAO;AAAED,MAAAA,IAAI,EAAE;AAAR,KAAP;AAAA;AACX;;;;;;AAH0B,CAAvB,C,CAUP;AACA;;AAEA,OAAO,IAAME,OAA8B,GAAG,SAAjCA,OAAiC,CAACC,KAAD,EAAkCC,cAAlC,EAA2E;AACrH,MAAID,KAAK,KAAKE,SAAd,EAAyB;AACrB,WAAO;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAAP;AACH;;AACDC,EAAAA,OAAO,CAACC,GAAR,CAAY,qBAAmBC,IAAI,CAACC,SAAL,CAAeN,cAAf,CAA/B;AACA,MAAMO,MAAM,GAAGP,cAAf;;AACA,UAAQO,MAAM,CAACX,IAAf;AACI,SAAK,iBAAL;AAEA,aAAO;AAAEM,QAAAA,KAAK,EAAEH,KAAK,CAACG,KAAN,GAAc;AAAvB,OAAP;;AACA,SAAK,iBAAL;AACI,aAAO;AAAEA,QAAAA,KAAK,EAAEH,KAAK,CAACG,KAAN,GAAc;AAAvB,OAAP;;AACJ;AACI,aAAOH,KAAP;AAPR;AASH,CAfM","sourcesContent":["import { Action, Reducer } from 'redux';\n\n// -----------------\n// STATE - This defines the type of data maintained in the Redux store.\n\nexport interface CounterState {\n    count: number;\n}\n\n// -----------------\n// ACTIONS - These are serializable (hence replayable) descriptions of state transitions.\n// They do not themselves have any side-effects; they just describe something that is going to happen.\n// Use @typeName and isActionType for type detection that works even after serialization/deserialization.\n\nexport interface IncrementCountAction { type: 'INCREMENT_COUNT' }\nexport interface DecrementCountAction { type: 'DECREMENT_COUNT' }\nexport interface ADD_TO_CART { type: 'ADD_TO_CART'}\n\n\n// Declare a 'discriminated union' type. This guarantees that all references to 'type' properties contain one of the\n// declared type strings (and not any other arbitrary string).\nexport type KnownAction = IncrementCountAction | DecrementCountAction;\n\n// ----------------\n// ACTION CREATORS - These are functions exposed to UI components that will trigger a state transition.\n// They don't directly mutate state, but they can have external side-effects (such as loading data).\n\nexport const actionCreators = {\n    increment: () => ({ payload:'data',type: 'INCREMENT_COUNT' } as IncrementCountAction),\n    decrement: () => ({ type: 'DECREMENT_COUNT' } as DecrementCountAction),\n    /* addToCart: (productId:any) => (dispatch, getState) => {\n        if (getState().products.byId[productId].inventory > 0) {\n          dispatch(addToCartUnsafe(productId))\n        }\n    } */\n};\n\n// ----------------\n// REDUCER - For a given state and action, returns the new state. To support time travel, this must not mutate the old state.\n\nexport const reducer: Reducer<CounterState> = (state: CounterState | undefined, incomingAction: Action): CounterState => {\n    if (state === undefined) {\n        return { count: 0 };\n    }\n    console.log('incomingAction: '+JSON.stringify(incomingAction))\n    const action = incomingAction as KnownAction;\n    switch (action.type) {\n        case 'INCREMENT_COUNT':\n            \n        return { count: state.count + 1 };\n        case 'DECREMENT_COUNT':\n            return { count: state.count - 1 };\n        default:\n            return state;\n    }\n};\n"]},"metadata":{},"sourceType":"module"}