{"ast":null,"code":"// -----------------\n// STATE - This defines the type of data maintained in the Redux store.\n// -----------------\n// ACTIONS - These are serializable (hence replayable) descriptions of state transitions.\n// They do not themselves have any side-effects; they just describe something that is going to happen.\n// Declare a 'discriminated union' type. This guarantees that all references to 'type' properties contain one of the\n// declared type strings (and not any other arbitrary string).\n// ----------------\n// ACTION CREATORS - These are functions exposed to UI components that will trigger a state transition.\n// They don't directly mutate state, but they can have external side-effects (such as loading data).\nexport var actionCreators = {\n  requestWeatherForecasts: function requestWeatherForecasts(startDateIndex) {\n    return function (dispatch, getState) {\n      // Only load data if it's something we don't already have (and are not already loading)\n      var appState = getState();\n\n      if (appState && appState.weatherForecasts && startDateIndex !== appState.weatherForecasts.startDateIndex) {\n        fetch(\"tarjeta\").then(function (response) {\n          return response.json();\n        }).then(function (data) {\n          dispatch({\n            type: 'RECEIVE_WEATHER_FORECASTS',\n            startDateIndex: startDateIndex,\n            tarjetas: data\n          });\n        });\n        dispatch({\n          type: 'REQUEST_WEATHER_FORECASTS',\n          startDateIndex: startDateIndex\n        });\n      }\n    };\n  }\n}; // ----------------\n// REDUCER - For a given state and action, returns the new state. To support time travel, this must not mutate the old state.\n\nvar unloadedState = {\n  tarjetas: [],\n  isLoading: false\n};\nexport var reducer = function reducer(state, incomingAction) {\n  if (state === undefined) {\n    return unloadedState;\n  }\n\n  var action = incomingAction;\n\n  switch (action.type) {\n    case 'REQUEST_WEATHER_FORECASTS':\n      return {\n        startDateIndex: action.startDateIndex,\n        tarjetas: state.tarjetas,\n        isLoading: true\n      };\n\n    case 'RECEIVE_WEATHER_FORECASTS':\n      // Only accept the incoming data if it matches the most recent request. This ensures we correctly\n      // handle out-of-order responses.\n      if (action.startDateIndex === state.startDateIndex) {\n        return {\n          startDateIndex: action.startDateIndex,\n          tarjetas: action.tarjetas,\n          isLoading: false\n        };\n      }\n\n      break;\n  }\n\n  return state;\n};","map":{"version":3,"sources":["C:/Users/Bus209/Documents/htdocs/CRUDReact/FBTarjeta/ClientApp/src/store/TarjetaCredito.ts"],"names":["actionCreators","requestWeatherForecasts","startDateIndex","dispatch","getState","appState","weatherForecasts","fetch","then","response","json","data","type","tarjetas","unloadedState","isLoading","reducer","state","incomingAction","undefined","action"],"mappings":"AAGA;AACA;AAUA;AACA;AACA;AAaA;AACA;AAGA;AACA;AACA;AAEA,OAAO,IAAMA,cAAc,GAAG;AAC1BC,EAAAA,uBAAuB,EAAE,iCAACC,cAAD;AAAA,WAAyD,UAACC,QAAD,EAAWC,QAAX,EAAwB;AACtG;AACA,UAAMC,QAAQ,GAAGD,QAAQ,EAAzB;;AACA,UAAIC,QAAQ,IAAIA,QAAQ,CAACC,gBAArB,IAAyCJ,cAAc,KAAKG,QAAQ,CAACC,gBAAT,CAA0BJ,cAA1F,EAA0G;AACtGK,QAAAA,KAAK,WAAL,CACKC,IADL,CACU,UAAAC,QAAQ;AAAA,iBAAIA,QAAQ,CAACC,IAAT,EAAJ;AAAA,SADlB,EAEKF,IAFL,CAEU,UAAAG,IAAI,EAAI;AACVR,UAAAA,QAAQ,CAAC;AAAES,YAAAA,IAAI,EAAE,2BAAR;AAAqCV,YAAAA,cAAc,EAAEA,cAArD;AAAqEW,YAAAA,QAAQ,EAAEF;AAA/E,WAAD,CAAR;AACH,SAJL;AAMAR,QAAAA,QAAQ,CAAC;AAAES,UAAAA,IAAI,EAAE,2BAAR;AAAqCV,UAAAA,cAAc,EAAEA;AAArD,SAAD,CAAR;AACH;AACJ,KAZwB;AAAA;AADC,CAAvB,C,CAgBP;AACA;;AAEA,IAAMY,aAAkC,GAAG;AAAED,EAAAA,QAAQ,EAAE,EAAZ;AAAgBE,EAAAA,SAAS,EAAE;AAA3B,CAA3C;AAEA,OAAO,IAAMC,OAAqC,GAAG,SAAxCA,OAAwC,CAACC,KAAD,EAAyCC,cAAzC,EAAyF;AAC1I,MAAID,KAAK,KAAKE,SAAd,EAAyB;AACrB,WAAOL,aAAP;AACH;;AAED,MAAMM,MAAM,GAAGF,cAAf;;AACA,UAAQE,MAAM,CAACR,IAAf;AACI,SAAK,2BAAL;AACI,aAAO;AACHV,QAAAA,cAAc,EAAEkB,MAAM,CAAClB,cADpB;AAEHW,QAAAA,QAAQ,EAAEI,KAAK,CAACJ,QAFb;AAGHE,QAAAA,SAAS,EAAE;AAHR,OAAP;;AAKJ,SAAK,2BAAL;AACI;AACA;AACA,UAAIK,MAAM,CAAClB,cAAP,KAA0Be,KAAK,CAACf,cAApC,EAAoD;AAChD,eAAO;AACHA,UAAAA,cAAc,EAAEkB,MAAM,CAAClB,cADpB;AAEHW,UAAAA,QAAQ,EAAEO,MAAM,CAACP,QAFd;AAGHE,UAAAA,SAAS,EAAE;AAHR,SAAP;AAKH;;AACD;AAjBR;;AAoBA,SAAOE,KAAP;AACH,CA3BM","sourcesContent":["import { Action, Reducer } from 'redux';\r\nimport { AppThunkAction } from './';\r\nimport { TarjetaCredito } from './../models/tarjetacredito';\r\n// -----------------\r\n// STATE - This defines the type of data maintained in the Redux store.\r\n\r\nexport interface WeatherTarjetaState {\r\n    isLoading: boolean;\r\n    startDateIndex?: number;\r\n    tarjetas: TarjetaCredito[];\r\n}\r\n\r\n\r\n\r\n// -----------------\r\n// ACTIONS - These are serializable (hence replayable) descriptions of state transitions.\r\n// They do not themselves have any side-effects; they just describe something that is going to happen.\r\n\r\ninterface RequestWeatherTarjetaAction {\r\n    type: 'REQUEST_WEATHER_FORECASTS';\r\n    startDateIndex: number;\r\n}\r\n\r\ninterface ReceiveWeatherTarjetaAction {\r\n    type: 'RECEIVE_WEATHER_FORECASTS';\r\n    startDateIndex: number;\r\n    tarjetas: TarjetaCredito[];\r\n}\r\n\r\n// Declare a 'discriminated union' type. This guarantees that all references to 'type' properties contain one of the\r\n// declared type strings (and not any other arbitrary string).\r\ntype KnownAction = RequestWeatherTarjetaAction | ReceiveWeatherTarjetaAction;\r\n\r\n// ----------------\r\n// ACTION CREATORS - These are functions exposed to UI components that will trigger a state transition.\r\n// They don't directly mutate state, but they can have external side-effects (such as loading data).\r\n\r\nexport const actionCreators = {\r\n    requestWeatherForecasts: (startDateIndex: number): AppThunkAction<KnownAction> => (dispatch, getState) => {\r\n        // Only load data if it's something we don't already have (and are not already loading)\r\n        const appState = getState();\r\n        if (appState && appState.weatherForecasts && startDateIndex !== appState.weatherForecasts.startDateIndex) {\r\n            fetch(`tarjeta`)\r\n                .then(response => response.json() as Promise<TarjetaCredito[]>)\r\n                .then(data => {\r\n                    dispatch({ type: 'RECEIVE_WEATHER_FORECASTS', startDateIndex: startDateIndex, tarjetas: data });\r\n                });\r\n\r\n            dispatch({ type: 'REQUEST_WEATHER_FORECASTS', startDateIndex: startDateIndex });\r\n        }\r\n    }\r\n};\r\n\r\n// ----------------\r\n// REDUCER - For a given state and action, returns the new state. To support time travel, this must not mutate the old state.\r\n\r\nconst unloadedState: WeatherTarjetaState = { tarjetas: [], isLoading: false };\r\n\r\nexport const reducer: Reducer<WeatherTarjetaState> = (state: WeatherTarjetaState | undefined, incomingAction: Action): WeatherTarjetaState => {\r\n    if (state === undefined) {\r\n        return unloadedState;\r\n    }\r\n\r\n    const action = incomingAction as KnownAction;\r\n    switch (action.type) {\r\n        case 'REQUEST_WEATHER_FORECASTS':\r\n            return {\r\n                startDateIndex: action.startDateIndex,\r\n                tarjetas: state.tarjetas,\r\n                isLoading: true\r\n            };\r\n        case 'RECEIVE_WEATHER_FORECASTS':\r\n            // Only accept the incoming data if it matches the most recent request. This ensures we correctly\r\n            // handle out-of-order responses.\r\n            if (action.startDateIndex === state.startDateIndex) {\r\n                return {\r\n                    startDateIndex: action.startDateIndex,\r\n                    tarjetas: action.tarjetas,\r\n                    isLoading: false\r\n                };\r\n            }\r\n            break;\r\n    }\r\n\r\n    return state;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}