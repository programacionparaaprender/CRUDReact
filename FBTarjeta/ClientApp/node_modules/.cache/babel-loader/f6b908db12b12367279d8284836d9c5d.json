{"ast":null,"code":"//import { Action, Reducer } from 'redux';\n// -----------------\n// ACTIONS - These are serializable (hence replayable) descriptions of state transitions.\n// They do not themselves have any side-effects; they just describe something that is going to happen.\n// Use @typeName and isActionType for type detection that works even after serialization/deserialization.\n// Declare a 'discriminated union' type. This guarantees that all references to 'type' properties contain one of the\n// declared type strings (and not any other arbitrary string).\n// ----------------\n// ACTION CREATORS - These are functions exposed to UI components that will trigger a state transition.\n// They don't directly mutate state, but they can have external side-effects (such as loading data).\nexport var actionCreators = {\n  increment: function increment() {\n    return {\n      payload: 'data',\n      type: 'INCREMENT_COUNT'\n    };\n  },\n  decrement: function decrement() {\n    return {\n      type: 'DECREMENT_COUNT'\n    };\n  },\n  addToCart: function addToCart(product) {\n    return {\n      payload: product,\n      type: 'ADD_TO_CART'\n    };\n  },\n  deleteProduct: function deleteProduct(id) {\n    return {\n      id: id,\n      type: 'DELETE_PRODUCT'\n    };\n  }\n}; // ----------------\n// REDUCER - For a given state and action, returns the new state. To support time travel, this must not mutate the old state.\n\nexport var reducer = function reducer(state, incomingAction) {\n  if (state === undefined) {\n    var products = [{\n      id: \"1\",\n      name: \"Product One\",\n      description: \"This is product one\",\n      price: \"29.99\"\n    }, {\n      id: \"2\",\n      name: \"Product Two\",\n      description: \"This is product two\",\n      price: \"39.99\"\n    }, {\n      id: \"3\",\n      name: \"Product Three\",\n      description: \"This is product three\",\n      price: \"59.99\"\n    }];\n    return {\n      products: products\n    };\n  } //console.log('incomingAction: '+JSON.stringify(incomingAction))\n\n\n  var action = incomingAction;\n\n  switch (action.type) {\n    case 'DELETE_PRODUCT':\n      action = incomingAction; //let products:Array<Producto>\n\n      var products2 = [];\n\n      for (var y in state.products) {\n        if (String(state.products[y].id) !== String(action.id)) products2.push(state.products[y]);\n      }\n\n      return {\n        products: products2\n      };\n\n    case 'ADD_TO_CART':\n      action = incomingAction; //let products:Array<Producto>\n\n      var _products = [];\n\n      for (var x in state.products) {\n        _products.push(state.products[x]);\n      }\n\n      _products.push({\n        id: action.payload.id,\n        name: action.payload.name,\n        description: action.payload.description,\n        price: action.payload.price\n      });\n\n      return {\n        products: _products\n      };\n\n    default:\n      return state;\n  }\n};","map":{"version":3,"sources":["C:/Users/Bus209/Documents/htdocs/CRUDReact/FBTarjeta/ClientApp/src/store/Product.ts"],"names":["actionCreators","increment","payload","type","decrement","addToCart","product","deleteProduct","id","reducer","state","incomingAction","undefined","products","name","description","price","action","products2","y","String","push","x"],"mappings":"AAAA;AAaA;AACA;AACA;AACA;AAiBA;AACA;AAGA;AACA;AACA;AAEA,OAAO,IAAMA,cAAc,GAAG;AAC1BC,EAAAA,SAAS,EAAE;AAAA,WAAO;AAAEC,MAAAA,OAAO,EAAC,MAAV;AAAiBC,MAAAA,IAAI,EAAE;AAAvB,KAAP;AAAA,GADe;AAE1BC,EAAAA,SAAS,EAAE;AAAA,WAAO;AAAED,MAAAA,IAAI,EAAE;AAAR,KAAP;AAAA,GAFe;AAG1BE,EAAAA,SAAS,EAAE,mBAACC,OAAD;AAAA,WAAuB;AAAEJ,MAAAA,OAAO,EAACI,OAAV;AAAkBH,MAAAA,IAAI,EAAE;AAAxB,KAAvB;AAAA,GAHe;AAI1BI,EAAAA,aAAa,EAAE,uBAACC,EAAD;AAAA,WAAgB;AAAEA,MAAAA,EAAE,EAACA,EAAL;AAAQL,MAAAA,IAAI,EAAE;AAAd,KAAhB;AAAA;AAJW,CAAvB,C,CAQP;AACA;;AAEA,OAAO,IAAMM,OAA8B,GAAG,SAAjCA,OAAiC,CAACC,KAAD,EAAkCC,cAAlC,EAAgF;AAC1H,MAAID,KAAK,KAAKE,SAAd,EAAyB;AACrB,QAAIC,QAAQ,GAAG,CACX;AACIL,MAAAA,EAAE,EAAC,GADP;AAEIM,MAAAA,IAAI,EAAC,aAFT;AAGIC,MAAAA,WAAW,EAAE,qBAHjB;AAIIC,MAAAA,KAAK,EAAE;AAJX,KADW,EAOX;AACIR,MAAAA,EAAE,EAAC,GADP;AAEIM,MAAAA,IAAI,EAAC,aAFT;AAGIC,MAAAA,WAAW,EAAE,qBAHjB;AAIIC,MAAAA,KAAK,EAAE;AAJX,KAPW,EAaX;AACIR,MAAAA,EAAE,EAAC,GADP;AAEIM,MAAAA,IAAI,EAAC,eAFT;AAGIC,MAAAA,WAAW,EAAE,uBAHjB;AAIIC,MAAAA,KAAK,EAAE;AAJX,KAbW,CAAf;AAoBA,WAAO;AAAEH,MAAAA,QAAQ,EAAEA;AAAZ,KAAP;AACH,GAvByH,CAwB1H;;;AACA,MAAII,MAAM,GAAGN,cAAb;;AACA,UAAQM,MAAM,CAACd,IAAf;AACI,SAAK,gBAAL;AACIc,MAAAA,MAAM,GAAGN,cAAT,CADJ,CAEI;;AACA,UAAIO,SAAS,GAAG,EAAhB;;AACA,WAAI,IAAIC,CAAR,IAAaT,KAAK,CAACG,QAAnB,EAA4B;AACxB,YAAGO,MAAM,CAACV,KAAK,CAACG,QAAN,CAAeM,CAAf,EAAkBX,EAAnB,CAAN,KAAiCY,MAAM,CAACH,MAAM,CAACT,EAAR,CAA1C,EACIU,SAAS,CAACG,IAAV,CAAeX,KAAK,CAACG,QAAN,CAAeM,CAAf,CAAf;AACP;;AACD,aAAQ;AAAEN,QAAAA,QAAQ,EAAEK;AAAZ,OAAR;;AAGJ,SAAK,aAAL;AACID,MAAAA,MAAM,GAAGN,cAAT,CADJ,CAEI;;AACA,UAAIE,SAAQ,GAAG,EAAf;;AACA,WAAI,IAAIS,CAAR,IAAaZ,KAAK,CAACG,QAAnB,EAA4B;AACxBA,QAAAA,SAAQ,CAACQ,IAAT,CAAcX,KAAK,CAACG,QAAN,CAAeS,CAAf,CAAd;AACH;;AACDT,MAAAA,SAAQ,CAACQ,IAAT,CAAc;AACVb,QAAAA,EAAE,EAAES,MAAM,CAACf,OAAP,CAAeM,EADT;AAEVM,QAAAA,IAAI,EAAEG,MAAM,CAACf,OAAP,CAAeY,IAFX;AAGVC,QAAAA,WAAW,EAACE,MAAM,CAACf,OAAP,CAAea,WAHjB;AAIVC,QAAAA,KAAK,EAAEC,MAAM,CAACf,OAAP,CAAec;AAJZ,OAAd;;AAMA,aAAQ;AAAEH,QAAAA,QAAQ,EAAEA;AAAZ,OAAR;;AAEJ;AACI,aAAOH,KAAP;AA5BR;AA8BH,CAxDM","sourcesContent":["//import { Action, Reducer } from 'redux';\nimport { Reducer } from 'redux';\nimport {Producto} from '../types'\n\n// -----------------\n// STATE - This defines the type of data maintained in the Redux store.\n\n\n\nexport interface ProductState{\n    //products:Array<Producto>\n    products:Producto[]\n}  \n// -----------------\n// ACTIONS - These are serializable (hence replayable) descriptions of state transitions.\n// They do not themselves have any side-effects; they just describe something that is going to happen.\n// Use @typeName and isActionType for type detection that works even after serialization/deserialization.\n\nexport interface IncrementCountAction { type: 'INCREMENT_COUNT' }\nexport interface DecrementCountAction { type: 'DECREMENT_COUNT' }\nexport interface ADD_TO_CART { \n    type: 'ADD_TO_CART',\n    payload:{\n        id: string;\n        name: string;\n        description:string\n        price: string;\n    }\n}\nexport interface DELETE_PRODUCT { \n    type: 'DELETE_PRODUCT',\n    id: string;\n}\n// Declare a 'discriminated union' type. This guarantees that all references to 'type' properties contain one of the\n// declared type strings (and not any other arbitrary string).\nexport type KnownAction = IncrementCountAction | DecrementCountAction | ADD_TO_CART | DELETE_PRODUCT;\n\n// ----------------\n// ACTION CREATORS - These are functions exposed to UI components that will trigger a state transition.\n// They don't directly mutate state, but they can have external side-effects (such as loading data).\n\nexport const actionCreators = {\n    increment: () => ({ payload:'data',type: 'INCREMENT_COUNT' } as IncrementCountAction),\n    decrement: () => ({ type: 'DECREMENT_COUNT' } as DecrementCountAction),\n    addToCart: (product:Producto) => ({ payload:product,type: 'ADD_TO_CART' } as ADD_TO_CART),  \n    deleteProduct: (id:string) => ({ id:id,type: 'DELETE_PRODUCT' } as DELETE_PRODUCT)  \n\n};\n\n// ----------------\n// REDUCER - For a given state and action, returns the new state. To support time travel, this must not mutate the old state.\n\nexport const reducer: Reducer<ProductState> = (state: ProductState | undefined, incomingAction: KnownAction): ProductState => {\n    if (state === undefined) {\n        let products = [\n            {\n                id:\"1\",\n                name:\"Product One\",\n                description: \"This is product one\",\n                price: \"29.99\",\n            },\n            {\n                id:\"2\",\n                name:\"Product Two\",\n                description: \"This is product two\",\n                price: \"39.99\",\n            },\n            {\n                id:\"3\",\n                name:\"Product Three\",\n                description: \"This is product three\",\n                price: \"59.99\",\n            }\n        ]\n        return { products: products };\n    }\n    //console.log('incomingAction: '+JSON.stringify(incomingAction))\n    var action = incomingAction as KnownAction;\n    switch (action.type) {\n        case 'DELETE_PRODUCT':\n            action = incomingAction as DELETE_PRODUCT;\n            //let products:Array<Producto>\n            let products2 = []\n            for(var y in state.products){\n                if(String(state.products[y].id) !== String(action.id))\n                    products2.push(state.products[y]);\n            } \n            return  { products: products2 };\n            \n\n        case 'ADD_TO_CART':\n            action = incomingAction as ADD_TO_CART;\n            //let products:Array<Producto>\n            let products = []\n            for(var x in state.products){\n                products.push(state.products[x]);\n            }\n            products.push({\n                id: action.payload.id,\n                name: action.payload.name,\n                description:action.payload.description,\n                price: action.payload.price\n            }); \n            return  { products: products };\n            \n        default:\n            return state;\n    }\n};\n"]},"metadata":{},"sourceType":"module"}